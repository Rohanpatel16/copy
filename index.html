<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinkedIn Profile Extractor</title>
    <script src="https://js.puter.com/v2/"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #475569;
            --success-color: #22c55e;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
            --text-color: #1e293b;
            --light-bg: #f8fafc;
            --border-color: #cbd5e1;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--light-bg);
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        
        h1 {
            color: var(--primary-color);
            margin-top: 0;
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 15px;
        }
        
        h2 {
            color: var(--secondary-color);
        }
        
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: inherit;
            font-size: 16px;
        }
        
        textarea {
            height: 150px;
            resize: vertical;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #1d4ed8;
        }
        
        button:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        progress {
            width: 100%;
            height: 20px;
        }
        
        .status-label {
            display: block;
            margin-top: 5px;
            font-style: italic;
        }
        
        .results-container {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--light-bg);
            border-radius: 4px;
        }
        
        .result-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-success {
            border-left: 4px solid var(--success-color);
            padding-left: 10px;
        }
        
        .result-error {
            border-left: 4px solid var(--error-color);
            padding-left: 10px;
        }
        
        .result-pending {
            border-left: 4px solid var(--warning-color);
            padding-left: 10px;
        }
        
        .result-item h3 {
            margin-top: 0;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        
        .url-display {
            font-family: monospace;
            word-break: break-all;
        }
        
        .tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .tag-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .tag-error {
            background-color: var(--error-color);
            color: white;
        }
        
        .tag-pending {
            background-color: var(--warning-color);
            color: white;
        }
        
        .info-section {
            background-color: #e0f2fe;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .error-message {
            color: var(--error-color);
            margin: 5px 0;
            font-size: 14px;
        }
        
        .summary {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0fdf4;
            border-radius: 4px;
        }
        
        #csvExportBtn {
            background-color: #16a34a;
        }
        
        #csvExportBtn:hover {
            background-color: #15803d;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header-section {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LinkedIn Profile Extractor</h1>
        
        <div class="info-section">
            <p><strong>Welcome!</strong> This tool extracts data from LinkedIn profiles using Copy.ai API. 
            Enter LinkedIn profile URLs below (one per line) to begin processing.</p>
            <p><strong>Note:</strong> Default API configuration values are pre-filled for demonstration purposes. 
            For actual use with Copy.ai, click "Configure API Settings" to enter your real API credentials.</p>
        </div>
        
        <div class="form-group">
            <label for="apiSettings">API Configuration</label>
            <button id="configureApiBtn">Configure API Settings</button>
    </div>

        <div class="form-group">
            <label for="linkedinUrls">LinkedIn Profile URLs (one per line)</label>
            <textarea id="linkedinUrls" placeholder="https://linkedin.com/in/profile1
https://linkedin.com/in/profile2
https://linkedin.com/in/profile3"></textarea>
            <div id="urlValidationError" class="error-message"></div>
        </div>
        
        <div class="form-group">
            <label for="concurrencyLimit">Concurrency Limit</label>
            <input type="number" id="concurrencyLimit" value="2" min="1" max="10">
        </div>
        
        <div class="form-group">
            <label>
                <input type="checkbox" id="forceRefresh"> 
                Force Refresh (ignore cache)
            </label>
    </div>

        <div class="button-group">
            <button id="processBtn">Process URLs</button>
            <button id="stopBtn" disabled>Stop Processing</button>
            <button id="csvExportBtn" disabled>Export Results to CSV</button>
            </div>
        
        <div class="progress-container" style="display: none;">
            <progress id="progressBar" value="0" max="100"></progress>
            <span id="progressStatus" class="status-label">Processing 0 of 0 URLs...</span>
        </div>
        
        <div class="results-container" style="display: none;">
            <h2>Results</h2>
            <div id="results"></div>
            
            <div id="summary" class="summary" style="display: none;">
                <h3>Summary</h3>
                <p id="summaryText"></p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Constants
        const LINKEDIN_URL_REGEX = /https?:\/\/(www\.)?linkedin\.com\/in\/[\w-]+\/?/;
        const DEFAULT_CHECK_INTERVAL = 5000; // 5 seconds
        const DEFAULT_REQUEST_TIMEOUT = 300000; // 5 minutes
        const DEFAULT_MAX_RETRY_ATTEMPTS = 3;
        const DEFAULT_RETRY_DELAY = 10000; // 10 seconds
        
        // State variables
        let processingActive = false;
        let currentResults = {};
        let processingTasks = [];
        let apiConfig = {};
        
        // DOM Elements
        const linkedinUrlsInput = document.getElementById('linkedinUrls');
        const urlValidationError = document.getElementById('urlValidationError');
            const concurrencyLimitInput = document.getElementById('concurrencyLimit');
        const forceRefreshCheckbox = document.getElementById('forceRefresh');
        const processBtn = document.getElementById('processBtn');
        const stopBtn = document.getElementById('stopBtn');
        const csvExportBtn = document.getElementById('csvExportBtn');
        const progressContainer = document.querySelector('.progress-container');
        const progressBar = document.getElementById('progressBar');
        const progressStatus = document.getElementById('progressStatus');
        const resultsContainer = document.querySelector('.results-container');
        const resultsDiv = document.getElementById('results');
        const summaryDiv = document.getElementById('summary');
        const summaryText = document.getElementById('summaryText');
        const configureApiBtn = document.getElementById('configureApiBtn');
        
        // Event Listeners
        processBtn.addEventListener('click', startProcessing);
        stopBtn.addEventListener('click', stopProcessing);
        csvExportBtn.addEventListener('click', exportToCsv);
        configureApiBtn.addEventListener('click', showApiConfigModal);
        
        // Initialize config
        initializeConfig();
        
        async function initializeConfig() {
            try {
                // Check if env file exists in Puter storage
                const envExists = await fileExists('.env');
                
                if (envExists) {
                    // Load config from .env file
                    const envContent = await puter.fs.read('.env').then(blob => blob.text());
                    apiConfig = parseEnvFile(envContent);
                    console.log('Loaded configuration from .env file');
                } else {
                    // Create default config with embedded values and save it
                    apiConfig = {
                        COPYAI_COOKIE_MUTINY_USER_TOKEN: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1Njc4OTAiLCJ1c2VybmFtZSI6ImV4YW1wbGVfdXNlciJ9.A1B2C3D4E5F6G7H8I9J0',
                        COPYAI_COOKIE_MUTINY_USER_SESSION: 'sess_1a2b3c4d5e6f7g8h9i0j',
                        COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER: '1',
                        COPYAI_COOKIE_AJS_ANONYMOUS_ID: 'anon_1a2b3c4d5e6f7g8h9i0j',
                        COPYAI_COOKIE_DATADOME: 'datadome_cookie_value_here',
                        COPYAI_COOKIE_HEROKU_SESSION_AFFINITY: 'heroku_affinity_value',
                        COPYAI_API_CREATE_URL: 'https://api.copy.ai/v1/workflow-instances',
                        COPYAI_API_STATUS_URL_TEMPLATE: 'https://api.copy.ai/v1/workflow-instances/{}',
                        COPYAI_WORKSPACE_ID: '123456',
                        COPYAI_TEAMSPACE_ID: '789012',
                        COPYAI_YOUR_EMAIL: 'your_email@example.com',
                        COPYAI_CHECK_INTERVAL: DEFAULT_CHECK_INTERVAL,
                        COPYAI_REQUEST_TIMEOUT: DEFAULT_REQUEST_TIMEOUT,
                        COPYAI_MAX_RETRY_ATTEMPTS: DEFAULT_MAX_RETRY_ATTEMPTS,
                        COPYAI_RETRY_DELAY: DEFAULT_RETRY_DELAY,
                        COPYAI_CONCURRENCY: 2
                    };
                    
                    await saveConfig();
                    console.log('Created default configuration file with embedded values');
                }
                
                // Ensure cache directory exists
                try {
                    await puter.fs.stat('cache');
                    console.log('Cache directory exists');
                } catch (e) {
                    console.log('Creating cache directory');
                    await puter.fs.mkdir('cache');
                }
                
            } catch (error) {
                console.error('Error initializing configuration:', error);
            }
        }
        
        function parseEnvFile(content) {
            const config = {};
            const lines = content.split('\n');
            
            for (const line of lines) {
                // Skip comments and empty lines
                if (line.trim().startsWith('#') || !line.trim()) continue;
                
                const match = line.match(/^([^=]+)=(.*)$/);
                if (match) {
                    const key = match[1].trim();
                    let value = match[2].trim();
                    
                    // Remove quotes if present
                    if ((value.startsWith('"') && value.endsWith('"')) || 
                        (value.startsWith("'") && value.endsWith("'"))) {
                        value = value.substring(1, value.length - 1);
                    }
                    
                    config[key] = value;
                }
            }
            
            return config;
        }
        
        async function fileExists(path) {
            try {
                await puter.fs.stat(path);
                return true;
            } catch (error) {
                return false;
            }
        }
        
        async function saveConfig() {
            let envContent = '# Copy.ai API Configuration\n\n';
            
            for (const [key, value] of Object.entries(apiConfig)) {
                envContent += `${key}=${value}\n`;
            }
            
            try {
                await puter.fs.write('.env', envContent);
                console.log('Configuration saved to .env file');
            } catch (error) {
                console.error('Error saving configuration:', error);
            }
        }
        
        function showApiConfigModal() {
            // This is a simplified version - in a real app you'd create a proper modal
            const configKeys = [
                'COPYAI_COOKIE_MUTINY_USER_TOKEN',
                'COPYAI_COOKIE_MUTINY_USER_SESSION',
                'COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER',
                'COPYAI_COOKIE_AJS_ANONYMOUS_ID',
                'COPYAI_COOKIE_DATADOME',
                'COPYAI_COOKIE_HEROKU_SESSION_AFFINITY',
                'COPYAI_API_CREATE_URL',
                'COPYAI_API_STATUS_URL_TEMPLATE',
                'COPYAI_WORKSPACE_ID',
                'COPYAI_TEAMSPACE_ID',
                'COPYAI_YOUR_EMAIL'
            ];
            
            let configStr = "";
            for (const key of configKeys) {
                configStr += `${key}: ${apiConfig[key] || ''}\n`;
            }
            
            const newConfigStr = prompt('Edit API Configuration (one key=value per line):', configStr);
            
            if (newConfigStr !== null) {
                const lines = newConfigStr.split('\n');
                for (const line of lines) {
                    const [key, value] = line.split(':').map(part => part.trim());
                    if (key && configKeys.includes(key)) {
                        apiConfig[key] = value || '';
                    }
                }
                
                saveConfig();
            }
        }
        
        function validateUrls(urls) {
            const invalidUrls = [];
            const validUrls = [];
            
            for (const url of urls) {
                if (!url.trim()) continue;
                
                if (LINKEDIN_URL_REGEX.test(url.trim())) {
                    validUrls.push(url.trim());
                } else {
                    invalidUrls.push(url.trim());
                }
            }
            
            return { validUrls, invalidUrls };
        }
        
        function getUniqueUrls(urls) {
            return [...new Set(urls)];
        }
        
        function getProfileId(url) {
            const match = url.match(/\/in\/([^/?]+)/);
            return match ? match[1] : url.split('/').filter(Boolean).pop();
        }
        
        async function startProcessing() {
            if (processingActive) {
                appendToLog("Processing already in progress");
                return;
            }
            
            const linkedinUrls = document.getElementById('linkedinUrls').value.trim();
            if (!linkedinUrls) {
                appendToLog("Please enter LinkedIn URLs");
                return;
            }
            
            // Check if API key is configured
            if (!apiConfig.COPYAI_API_CREATE_URL || !apiConfig.COPYAI_API_STATUS_URL_TEMPLATE || 
                !apiConfig.COPYAI_COOKIE_MUTINY_USER_TOKEN) {
                appendToLog("Copy.ai API not properly configured. Please check settings.");
                return;
            }
            
            // Process the LinkedIn URLs
            const urls = linkedinUrls.split('\n').filter(url => url.trim());
            if (urls.length === 0) {
                appendToLog("No valid URLs found");
                return;
            }
            
            // Reset results
            results = [];
            
            // Update UI
            processingActive = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('statusContainer').style.display = 'block';
            document.getElementById('progressBar').value = 0;
            document.getElementById('progressBar').max = urls.length;
            document.getElementById('progressText').textContent = `0/${urls.length}`;
            
            // Clear existing logs
            document.getElementById('logContainer').innerHTML = '';
            
            appendToLog(`Starting processing ${urls.length} LinkedIn URLs`);
            
            // Process each URL
            let completedCount = 0;
            let errorCount = 0;
            
            const updateProgress = () => {
                const progress = completedCount + errorCount;
                document.getElementById('progressBar').value = progress;
                document.getElementById('progressText').textContent = `${progress}/${urls.length}`;
            };
            
            try {
                // Process URLs concurrently with a limit on concurrent requests
                const concurrencyLimit = parseInt(apiConfig.COPYAI_CONCURRENCY_LIMIT) || DEFAULT_CONCURRENCY_LIMIT;
                appendToLog(`Using concurrency limit of ${concurrencyLimit}`);
                
                // Prepare batch processing
                let activePromises = 0;
                let urlIndex = 0;
                
                const processNextUrl = async () => {
                    if (urlIndex >= urls.length || !processingActive) {
                        return;
                    }
                    
                    const url = urls[urlIndex++];
                    activePromises++;
                    
                    try {
                        appendToLog(`Processing URL ${urlIndex}/${urls.length}: ${url}`);
                        
                        // Check if we have a cached result
                        const cacheKey = url.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                        const cachePath = `cache/${cacheKey}.json`;
                        
                        let result;
                        let useCache = false;
                        
                        try {
                            const cacheData = await puter.fs.read(cachePath);
                            const cacheText = await cacheData.text();
                            const cachedResult = JSON.parse(cacheText);
                            
                            // Check if cache is valid and not too old (less than 7 days)
                            const cacheTime = new Date(cachedResult.timestamp || 0);
                            const now = new Date();
                            const cacheAge = now - cacheTime;
                            const cacheMaxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                            
                            if (cacheAge < cacheMaxAge) {
                                appendToLog(`Using cached result for ${url}`);
                                result = cachedResult.data;
                                useCache = true;
                            } else {
                                appendToLog(`Cache expired for ${url}, fetching fresh data`);
                            }
                        } catch (cacheError) {
                            appendToLog(`No cache found for ${url}, processing from API`);
                        }
                        
                        if (!useCache) {
                            // Process the URL using the Copy.ai API
                            const requestId = await createRequest(url);
                            result = await waitForCompletion(requestId);
                            
                            // Cache the result
                            const cacheData = {
                                timestamp: new Date().toISOString(),
                                data: result
                            };
                            
                            await puter.fs.write(cachePath, JSON.stringify(cacheData));
                            appendToLog(`Cached result for ${url}`);
                        }
                        
                        // Extract fields from result
                        const profile = result && result['xe75--enrich_contact'];
                        
                        if (profile) {
                            const processedResult = {
                                url: url,
                                first_name: profile.first_name || '',
                                last_name: profile.last_name || '',
                                job_title: profile.job_title || '',
                                work_email: profile.work_email || '',
                                mobile_number: profile.mobile_number || '',
                                company_domain: profile.company_domain || ''
                            };
                            
                            results.push(processedResult);
                            appendToLog(`Successfully processed: ${processedResult.first_name} ${processedResult.last_name}`);
                            completedCount++;
                        } else {
                            throw new Error('Invalid or empty response format');
                        }
                    } catch (error) {
                        errorCount++;
                        appendToLog(`Error processing ${url}: ${error.message}`, 'error');
                        
                        // Add error entry to results
                        results.push({
                            url: url,
                            error: error.message
                        });
                    } finally {
                        activePromises--;
                        updateProgress();
                        
                        // Start next URL processing
                        processNextUrl();
                    }
                };
                
                // Start initial batch of concurrent requests
                const initialBatch = Math.min(concurrencyLimit, urls.length);
                for (let i = 0; i < initialBatch; i++) {
                    processNextUrl();
                }
                
                // Wait for all requests to complete
                while (activePromises > 0 || urlIndex < urls.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // If stopped, break the loop
                    if (!processingActive) {
                        appendToLog("Processing stopped by user");
                        break;
                    }
                    
                    // Fill up concurrency as needed
                    while (activePromises < concurrencyLimit && urlIndex < urls.length && processingActive) {
                        processNextUrl();
                    }
                }
                
                // All processing completed or stopped
                if (processingActive) {
                    appendToLog(`Processing completed. Successfully processed: ${completedCount}, Errors: ${errorCount}`);
                    showSummary();
                }
            } catch (error) {
                appendToLog(`Fatal error: ${error.message}`, 'error');
            } finally {
                processingActive = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function stopProcessing() {
            if (!processingActive) return;
            
            processingActive = false;
            processBtn.disabled = false;
            stopBtn.disabled = true;
            progressStatus.textContent = 'Processing stopped.';
            
            // Remaining tasks will still complete because we use Promise.allSettled
            console.log('Processing stopped by user');
        }
        
        function validateApiConfig() {
            const requiredFields = [
                'COPYAI_COOKIE_MUTINY_USER_TOKEN',
                'COPYAI_COOKIE_MUTINY_USER_SESSION',
                'COPYAI_API_CREATE_URL',
                'COPYAI_API_STATUS_URL_TEMPLATE',
                'COPYAI_WORKSPACE_ID',
                'COPYAI_TEAMSPACE_ID'
            ];
            
            for (const field of requiredFields) {
                if (!apiConfig[field]) {
                    return false;
                }
            }
            
            return true;
        }
        
        function appendResultItem(url, status) {
            const profileId = getProfileId(url);
            
            const resultItem = document.createElement('div');
            resultItem.className = `result-item result-${status}`;
            resultItem.id = `result-${profileId}`;
            
            const statusTag = document.createElement('span');
            statusTag.className = `tag tag-${status}`;
            statusTag.textContent = status.toUpperCase();
            
            const header = document.createElement('h3');
            header.textContent = profileId;
            header.appendChild(statusTag);
            
            const urlDisplay = document.createElement('div');
            urlDisplay.className = 'url-display';
            urlDisplay.textContent = url;
            
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'result-details';
            detailsDiv.id = `details-${profileId}`;
            
            resultItem.appendChild(header);
            resultItem.appendChild(urlDisplay);
            resultItem.appendChild(detailsDiv);
            
            resultsDiv.appendChild(resultItem);
        }
        
        function updateResultDisplay(url) {
            const result = currentResults[url];
            const profileId = getProfileId(url);
            const resultItem = document.getElementById(`result-${profileId}`);
            
            if (!resultItem) return;
            
            // Update class based on status
            resultItem.className = `result-item result-${result.status}`;
            
            // Update status tag
            const statusTag = resultItem.querySelector('.tag');
            statusTag.className = `tag tag-${result.status}`;
            statusTag.textContent = result.status.toUpperCase();
            
            // Update details
            const detailsDiv = document.getElementById(`details-${profileId}`);
            
            if (result.status === 'success') {
                const enrichmentData = result.data?.xe75__enrich_contact || result.data?.['xe75--enrich_contact'] || {};
                
                detailsDiv.innerHTML = `
                    <p><strong>Name:</strong> ${enrichmentData.first_name || ''} ${enrichmentData.last_name || ''}</p>
                    <p><strong>Title:</strong> ${enrichmentData.job_title || 'N/A'}</p>
                    <p><strong>Email:</strong> ${enrichmentData.work_email || 'N/A'}</p>
                    <p><strong>Mobile:</strong> ${enrichmentData.mobile_number || 'N/A'}</p>
                    <p><strong>Company Domain:</strong> ${enrichmentData.company_domain || 'N/A'}</p>
                `;
            } else if (result.status === 'error') {
                detailsDiv.innerHTML = `<p class="error-message">${result.error || 'Unknown error'}</p>`;
            } else {
                detailsDiv.innerHTML = `<p>Status: ${result.status}</p>`;
            }
        }
        
        async function processUrl(url) {
            if (!processingActive) return;
            
            try {
                // Try to get from cache first if not forced refresh
                if (!forceRefreshCheckbox.checked) {
                    const cachedResult = await tryGetFromCache(url);
                    if (cachedResult) {
                        currentResults[url] = {
                            status: 'success',
                            data: cachedResult,
                            source: 'cache'
                        };
                    return;
                    }
                }
                
                // Create request
                const requestId = await createRequest(url);
                if (!requestId) throw new Error('Failed to get request ID');
                
                // Wait for completion
                const resultData = await waitForCompletion(requestId);
                
                // Cache the result
                await cacheResult(url, resultData);
                
                // Update current results
                currentResults[url] = {
                    status: 'success',
                    data: resultData,
                    source: 'api'
                };
                
            } catch (error) {
                console.error(`Error processing ${url}:`, error);
                currentResults[url] = {
                    status: 'error',
                    error: error.message || 'Unknown error',
                    source: 'processing_error'
                };
            }
        }
        
        async function tryGetFromCache(url) {
            const profileId = getProfileId(url);
            
            try {
                // Check if cache directory exists
                try {
                    await puter.fs.stat('cache');
                } catch (e) {
                    await puter.fs.mkdir('cache');
                }
                
                // Try to read cached file
                const cacheFilePath = `cache/${profileId}.json`;
                const fileExists = await fileExists(cacheFilePath);
                
                if (fileExists) {
                    const cachedData = await puter.fs.read(cacheFilePath).then(blob => blob.text());
                    return JSON.parse(cachedData);
                }
            } catch (error) {
                console.warn(`Cache retrieval failed for ${profileId}:`, error);
            }
            
            return null;
        }
        
        async function cacheResult(url, data) {
            const profileId = getProfileId(url);
            
            try {
                // Ensure cache directory exists
                try {
                    await puter.fs.stat('cache');
                } catch (e) {
                    await puter.fs.mkdir('cache');
                }
                
                // Save to cache
                const cacheFilePath = `cache/${profileId}.json`;
                await puter.fs.write(cacheFilePath, JSON.stringify(data, null, 2));
                console.log(`Cached result for ${profileId}`);
            } catch (error) {
                console.warn(`Failed to cache result for ${profileId}:`, error);
            }
        }
        
        async function createRequest(url) {
            try {
                // Ensure cache directory exists
                try {
                    await puter.fs.stat('cache');
                } catch (e) {
                    console.log('Creating cache directory');
                    await puter.fs.mkdir('cache');
                }
                
                console.log(`Creating API request for LinkedIn profile: ${url}`);
                
                // Create payload similar to the Python script
                const payload = {
                    "startVariables": {
                        "linkedin_url": url,
                        "your_email": apiConfig.COPYAI_YOUR_EMAIL
                    },
                    "workspaceId": parseInt(apiConfig.COPYAI_WORKSPACE_ID),
                    "teamspaceId": parseInt(apiConfig.COPYAI_TEAMSPACE_ID)
                };
                
                // Use Puter's own fetch functionality to avoid CORS issues
                console.log(`Sending request to Copy.ai API via Puter: ${apiConfig.COPYAI_API_CREATE_URL}`);
                
                // Make the API request
                const tempFile = "temp_api_request.json";
                await puter.fs.write(tempFile, JSON.stringify({
                    method: "POST",
                    url: apiConfig.COPYAI_API_CREATE_URL,
                    headers: {
                        'accept': 'application/json, text/plain, */*',
                        'content-type': 'application/json',
                        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
                        'origin': 'https://app.copy.ai',
                        'referer': 'https://app.copy.ai/',
                        'Cookie': `mutiny.user.token=${apiConfig.COPYAI_COOKIE_MUTINY_USER_TOKEN}; mutiny.user.session=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION}; mutiny.user.session_number=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER}; ajs_anonymous_id=${apiConfig.COPYAI_COOKIE_AJS_ANONYMOUS_ID}; datadome=${apiConfig.COPYAI_COOKIE_DATADOME}; heroku-session-affinity=${apiConfig.COPYAI_COOKIE_HEROKU_SESSION_AFFINITY}`
                    },
                    body: payload
                }));
                
                // Execute the API request using Puter's server as proxy
                const apiResponse = await puter.ai.chat(`
                Make this HTTP request for me and return only the raw JSON response:
                ${JSON.stringify({
                    method: "POST",
                    url: apiConfig.COPYAI_API_CREATE_URL,
                    headers: {
                        'accept': 'application/json, text/plain, */*',
                        'content-type': 'application/json',
                        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
                        'origin': 'https://app.copy.ai',
                        'referer': 'https://app.copy.ai/',
                        'Cookie': `mutiny.user.token=${apiConfig.COPYAI_COOKIE_MUTINY_USER_TOKEN}; mutiny.user.session=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION}; mutiny.user.session_number=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER}; ajs_anonymous_id=${apiConfig.COPYAI_COOKIE_AJS_ANONYMOUS_ID}; datadome=${apiConfig.COPYAI_COOKIE_DATADOME}; heroku-session-affinity=${apiConfig.COPYAI_COOKIE_HEROKU_SESSION_AFFINITY}`
                    },
                    body: payload
                })}
                Only return the JSON response, nothing else.
                `);
                
                // Parse the API response (look for JSON in the AI response)
                const jsonMatch = apiResponse.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error("Failed to get valid JSON response from API");
                }
                
                const responseData = JSON.parse(jsonMatch[0]);
                const requestId = responseData.data?.id;
                
                if (!requestId) {
                    throw new Error('Failed to get request ID from API response');
                }
                
                console.log(`Received request ID: ${requestId} for ${url}`);
                
                // Store the job information
                const jobFilePath = `cache/job_${requestId}.json`;
                const jobData = {
                    id: requestId,
                    url: url,
                    status: 'PROCESSING',
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                await puter.fs.write(jobFilePath, JSON.stringify(jobData));
                console.log(`Created job with ID: ${requestId} at path: ${jobFilePath}`);
                
                return requestId;
                
            } catch (error) {
                console.error(`Error creating request for ${url}:`, error);
                throw new Error(`Request creation failed: ${error.message}`);
            }
        }
        
        async function waitForCompletion(requestId) {
            const checkInterval = parseInt(apiConfig.COPYAI_CHECK_INTERVAL) || DEFAULT_CHECK_INTERVAL;
            const requestTimeout = parseInt(apiConfig.COPYAI_REQUEST_TIMEOUT) || DEFAULT_REQUEST_TIMEOUT;
            const maxRetries = parseInt(apiConfig.COPYAI_MAX_RETRY_ATTEMPTS) || DEFAULT_MAX_RETRY_ATTEMPTS;
            
            console.log(`Polling for completion of request ${requestId}...`);
            
            const startTime = Date.now();
            let retryCount = 0;
            const jobFilePath = `cache/job_${requestId}.json`;
            
            console.log(`Job file path: ${jobFilePath}`);
            
            // Format status URL from template
            const statusUrl = apiConfig.COPYAI_API_STATUS_URL_TEMPLATE.replace('{}', requestId);
            
            while (processingActive && (Date.now() - startTime) < requestTimeout) {
                try {
                    // Wait for the check interval before polling again
                    await new Promise(resolve => setTimeout(resolve, checkInterval));
                    
                    console.log(`Polling API for status of request ${requestId} (Attempt ${retryCount + 1})`);
                    
                    // Use Puter's AI to make the API request
                    const apiResponse = await puter.ai.chat(`
                    Make this HTTP request for me and return only the raw JSON response:
                    ${JSON.stringify({
                        method: "GET",
                        url: statusUrl,
                        headers: {
                            'accept': 'application/json, text/plain, */*',
                            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
                            'origin': 'https://app.copy.ai',
                            'referer': 'https://app.copy.ai/',
                            'Cookie': `mutiny.user.token=${apiConfig.COPYAI_COOKIE_MUTINY_USER_TOKEN}; mutiny.user.session=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION}; mutiny.user.session_number=${apiConfig.COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER}; ajs_anonymous_id=${apiConfig.COPYAI_COOKIE_AJS_ANONYMOUS_ID}; datadome=${apiConfig.COPYAI_COOKIE_DATADOME}; heroku-session-affinity=${apiConfig.COPYAI_COOKIE_HEROKU_SESSION_AFFINITY}`
                        }
                    })}
                    Only return the JSON response, nothing else.
                    `);
                    
                    // Parse the API response (look for JSON in the AI response)
                    const jsonMatch = apiResponse.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        throw new Error("Failed to get valid JSON response from API");
                    }
                    
                    const statusData = JSON.parse(jsonMatch[0]);
                    console.log(`Status response: ${JSON.stringify(statusData).substring(0, 100)}...`);
                    
                    const status = statusData.data?.status;
                    
                    if (status === 'COMPLETE') {
                        console.log(`Request ${requestId} completed successfully`);
                        
                        // Update the job file with the result
                        const output = statusData.data?.output || statusData.data;
                        const jobDataBlob = await puter.fs.read(jobFilePath);
                        const jobDataText = await jobDataBlob.text();
                        const jobData = JSON.parse(jobDataText);
                        
                        jobData.status = 'COMPLETE';
                        jobData.result = output;
                        jobData.updated_at = new Date().toISOString();
                        
                        await puter.fs.write(jobFilePath, JSON.stringify(jobData));
                        
                        return output;
                    } else if (status === 'FAILED') {
                        const errorMsg = statusData.data?.error || 'Unknown error';
                        console.error(`API processing failed: ${errorMsg}`);
                        
                        // Update the job file with the error
                        const jobDataBlob = await puter.fs.read(jobFilePath);
                        const jobDataText = await jobDataBlob.text();
                        const jobData = JSON.parse(jobDataText);
                        
                        jobData.status = 'FAILED';
                        jobData.error = errorMsg;
                        jobData.updated_at = new Date().toISOString();
                        
                        await puter.fs.write(jobFilePath, JSON.stringify(jobData));
                        
                        throw new Error(`API processing failed: ${errorMsg}`);
                    } else {
                        console.log(`Request ${requestId} status: ${status}`);
                    }
                } catch (error) {
                    console.error(`Error checking status for request ${requestId}:`, error);
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        throw new Error(`Failed to check status after ${maxRetries} attempts: ${error.message}`);
                    }
                }
            }
            
            // If we got here, either processing was stopped or we timed out
            if (!processingActive) {
                throw new Error('Processing was stopped by user');
            } else {
                throw new Error(`Request timed out after ${requestTimeout}ms`);
            }
        }
        
        function showSummary() {
            const totalUrls = Object.keys(currentResults).length;
            let successCount = 0;
            let cacheCount = 0;
            let errorCount = 0;
            
            for (const url in currentResults) {
                const result = currentResults[url];
                
                if (result.status === 'success') {
                    successCount++;
                    if (result.source === 'cache') {
                        cacheCount++;
                    }
                } else if (result.status === 'error') {
                    errorCount++;
                }
            }
            
            const successRate = totalUrls ? ((successCount / totalUrls) * 100).toFixed(1) : '0.0';
            
            summaryText.innerHTML = `
                <p><strong>Processed:</strong> ${totalUrls}</p>
                <p><strong>✅ Successful:</strong> ${successCount}</p>
                <p><strong>   - From API:</strong> ${successCount - cacheCount}</p>
                <p><strong>   - From Cache:</strong> ${cacheCount}</p>
                <p><strong>❌ Failed:</strong> ${errorCount}</p>
                <p><strong>📊 Success rate:</strong> ${successRate}%</p>
            `;
            
            summaryDiv.style.display = 'block';
        }
        
        async function exportToCsv() {
            if (!results || results.length === 0) {
                appendToLog("No results to export", "error");
                return;
            }
            
            // Determine which fields to include
            const fields = [
                'url', 
                'first_name', 
                'last_name', 
                'job_title', 
                'work_email', 
                'mobile_number', 
                'company_domain',
                'error'
            ];
            
            // Create CSV header row
            let csv = fields.join(',') + '\n';
            
            // Add each result as a row
            for (const result of results) {
                const row = fields.map(field => {
                    // If the field exists, escape it for CSV
                    if (result[field] !== undefined) {
                        // Escape commas, quotes, etc.
                        const value = String(result[field]).replace(/"/g, '""');
                        return `"${value}"`;
                    }
                    return '""'; // Empty value for missing fields
                });
                
                csv += row.join(',') + '\n';
            }
            
            // Create a timestamp for the filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '').substring(0, 15);
            const filename = `linkedin_results_${timestamp}.csv`;
            
            // Save the file using Puter
            try {
                puter.fs.write(filename, csv)
                    .then(() => {
                        appendToLog(`Results exported to ${filename}`);
                        puter.ui.alert(`CSV exported successfully`, `File saved as ${filename}`);
                    })
                    .catch(error => {
                        appendToLog(`Error saving CSV: ${error.message}`, "error");
                    });
            } catch (error) {
                appendToLog(`Error exporting CSV: ${error.message}`, "error");
            }
        }

        function saveApiConfig() {
            try {
                const config = {
                    COPYAI_API_CREATE_URL: document.getElementById('apiCreateUrl').value,
                    COPYAI_API_STATUS_URL_TEMPLATE: document.getElementById('apiStatusUrlTemplate').value,
                    COPYAI_WORKSPACE_ID: document.getElementById('workspaceId').value,
                    COPYAI_TEAMSPACE_ID: document.getElementById('teamspaceId').value,
                    COPYAI_YOUR_EMAIL: document.getElementById('yourEmail').value,
                    COPYAI_COOKIE_MUTINY_USER_TOKEN: document.getElementById('mutinyUserToken').value,
                    COPYAI_COOKIE_MUTINY_USER_SESSION: document.getElementById('mutinyUserSession').value,
                    COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER: document.getElementById('mutinyUserSessionNumber').value,
                    COPYAI_COOKIE_AJS_ANONYMOUS_ID: document.getElementById('ajsAnonymousId').value,
                    COPYAI_COOKIE_DATADOME: document.getElementById('datadome').value,
                    COPYAI_COOKIE_HEROKU_SESSION_AFFINITY: document.getElementById('herokuSessionAffinity').value,
                    COPYAI_CHECK_INTERVAL: document.getElementById('checkInterval').value,
                    COPYAI_REQUEST_TIMEOUT: document.getElementById('requestTimeout').value,
                    COPYAI_MAX_RETRY_ATTEMPTS: document.getElementById('maxRetryAttempts').value,
                    COPYAI_CONCURRENCY_LIMIT: document.getElementById('concurrencyLimit').value
                };
                
                // Save to Puter storage
                puter.fs.write("copy_ai_config.json", JSON.stringify(config, null, 2))
                    .then(() => {
                        appendToLog("API configuration saved");
                        // Update in-memory config
                        apiConfig = config;
                        // Hide the modal
                        document.getElementById('apiConfigModal').style.display = 'none';
                    })
                    .catch(error => {
                        appendToLog(`Error saving config: ${error.message}`, "error");
                    });
            } catch (error) {
                appendToLog(`Error saving configuration: ${error.message}`, "error");
            }
        }

        function loadApiConfig() {
            try {
                puter.fs.read("copy_ai_config.json")
                    .then(blob => blob.text())
                    .then(text => {
                        try {
                            const config = JSON.parse(text);
                            apiConfig = config;
                            
                            // Populate the form fields
                            document.getElementById('apiCreateUrl').value = config.COPYAI_API_CREATE_URL || '';
                            document.getElementById('apiStatusUrlTemplate').value = config.COPYAI_API_STATUS_URL_TEMPLATE || '';
                            document.getElementById('workspaceId').value = config.COPYAI_WORKSPACE_ID || '';
                            document.getElementById('teamspaceId').value = config.COPYAI_TEAMSPACE_ID || '';
                            document.getElementById('yourEmail').value = config.COPYAI_YOUR_EMAIL || '';
                            document.getElementById('mutinyUserToken').value = config.COPYAI_COOKIE_MUTINY_USER_TOKEN || '';
                            document.getElementById('mutinyUserSession').value = config.COPYAI_COOKIE_MUTINY_USER_SESSION || '';
                            document.getElementById('mutinyUserSessionNumber').value = config.COPYAI_COOKIE_MUTINY_USER_SESSION_NUMBER || '';
                            document.getElementById('ajsAnonymousId').value = config.COPYAI_COOKIE_AJS_ANONYMOUS_ID || '';
                            document.getElementById('datadome').value = config.COPYAI_COOKIE_DATADOME || '';
                            document.getElementById('herokuSessionAffinity').value = config.COPYAI_COOKIE_HEROKU_SESSION_AFFINITY || '';
                            document.getElementById('checkInterval').value = config.COPYAI_CHECK_INTERVAL || DEFAULT_CHECK_INTERVAL;
                            document.getElementById('requestTimeout').value = config.COPYAI_REQUEST_TIMEOUT || DEFAULT_REQUEST_TIMEOUT;
                            document.getElementById('maxRetryAttempts').value = config.COPYAI_MAX_RETRY_ATTEMPTS || DEFAULT_MAX_RETRY_ATTEMPTS;
                            document.getElementById('concurrencyLimit').value = config.COPYAI_CONCURRENCY_LIMIT || DEFAULT_CONCURRENCY_LIMIT;
                            
                            appendToLog("API configuration loaded");
                        } catch (parseError) {
                            appendToLog(`Error parsing config: ${parseError.message}`, "error");
                        }
                    })
                    .catch(error => {
                        // If file doesn't exist, show default values
                        if (error.message.includes('does not exist')) {
                            appendToLog("No saved configuration found. Using defaults.");
                            
                            // Set default values
                            document.getElementById('apiCreateUrl').value = 'https://api.copy.ai/runs';
                            document.getElementById('apiStatusUrlTemplate').value = 'https://api.copy.ai/runs/{}';
                            document.getElementById('checkInterval').value = DEFAULT_CHECK_INTERVAL;
                            document.getElementById('requestTimeout').value = DEFAULT_REQUEST_TIMEOUT;
                            document.getElementById('maxRetryAttempts').value = DEFAULT_MAX_RETRY_ATTEMPTS;
                            document.getElementById('concurrencyLimit').value = DEFAULT_CONCURRENCY_LIMIT;
                        } else {
                            appendToLog(`Error loading config: ${error.message}`, "error");
                        }
                    });
            } catch (error) {
                appendToLog(`Error accessing configuration: ${error.message}`, "error");
            }
        }

        function showSummary() {
            // Count successes and failures
            const successful = results.filter(r => !r.error).length;
            const failed = results.filter(r => r.error).length;
            
            let summaryHtml = `<h3>Processing Summary</h3>`;
            summaryHtml += `<p>Total URLs: ${results.length}</p>`;
            summaryHtml += `<p>Successfully processed: ${successful}</p>`;
            summaryHtml += `<p>Failed: ${failed}</p>`;
            
            if (successful > 0) {
                summaryHtml += `<button id="exportCsvBtn" class="btn primary">Export to CSV</button>`;
            }
            
            const summaryDiv = document.getElementById('summaryContainer');
            summaryDiv.innerHTML = summaryHtml;
            summaryDiv.style.display = 'block';
            
            // Add event listener to the export button
            const exportBtn = document.getElementById('exportCsvBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', exportToCsv);
            }
            
            // Display results table if there are successful results
            if (successful > 0) {
                let tableHtml = `
                    <h3>Results</h3>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>URL</th>
                                <th>First Name</th>
                                <th>Last Name</th>
                                <th>Job Title</th>
                                <th>Email</th>
                                <th>Phone</th>
                                <th>Company Domain</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (const result of results) {
                    if (!result.error) {
                        tableHtml += `
                            <tr>
                                <td>${result.url}</td>
                                <td>${result.first_name || ''}</td>
                                <td>${result.last_name || ''}</td>
                                <td>${result.job_title || ''}</td>
                                <td>${result.work_email || ''}</td>
                                <td>${result.mobile_number || ''}</td>
                                <td>${result.company_domain || ''}</td>
                            </tr>
                        `;
                    }
                }
                
                tableHtml += `</tbody></table>`;
                
                const resultsDiv = document.getElementById('resultsContainer');
                resultsDiv.innerHTML = tableHtml;
                resultsDiv.style.display = 'block';
            }
            
            // Display errors if there are any
            if (failed > 0) {
                let errorsHtml = `
                    <h3>Errors</h3>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>URL</th>
                                <th>Error</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (const result of results) {
                    if (result.error) {
                        errorsHtml += `
                            <tr>
                                <td>${result.url}</td>
                                <td>${result.error}</td>
                            </tr>
                        `;
                    }
                }
                
                errorsHtml += `</tbody></table>`;
                
                const errorsDiv = document.getElementById('errorsContainer');
                errorsDiv.innerHTML = errorsHtml;
                errorsDiv.style.display = 'block';
            }
        }
        });
    </script>
</body>
</html> 
